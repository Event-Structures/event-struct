\section{Implementation}

\subsection{How we encode Event Structures}
% Как мы видели ранее в Step-by-step example наша стуркура событий содержит такие функции как frf fpred. Сами события это элементы некоторого множества E (множества итендификаторов), которое должно удволетворять следущим свойствам:
\begin{definition}[identifier set]
  $\mathcal{E}$ is an identifier set if:
  \begin{itemize}
    \item There is some $ident_0 \in \mathcal{E}$ ~--- first identifier
    \item $\mathcal{E}$ has well-founded partitial order $\leqslant_\mathcal{E}$
    \item There is some function, that takes some finite identifies set $E \subset \mathcal{E}$ and returns a fresh identifier. Formally: $fresh : \mathcal{P}_{fin}(\mathcal{E}) \to \mathcal{E}$, satisfies $$\forall e \in E, \ e <_\mathcal{E} fresh(E)$$
  \end{itemize}
\end{definition}
% Пусть E это множества всех событий программы тогда у нас есть
  $$\ffun{lab} : E \rightharpoonup \lb $$
% где label -- множество всех меток (таких как W(x, 5), R(y, 6), ThreadStart, ThreadEnd etc)
% Мы будем говорить что е это "read"-event c локацией х и значением i если lab(e) = R(x,i), аналогично "write"-event
% В итоге формально мы строим четверку
\begin{definition}[Execution Event Structure]
  $$exec\_event\_structure \ \triangleq \ \langle E, \ \ffun{lab}, \ \fpred, \ \frf \rangle$$
  where
  \begin{itemize}
    \item $E$ ~--- finite subset of some identifiers set $\mathcal{E}$
    \item $\fpred$ ~--- function that returns a predsessor (w.r.t. the program order) of event
    \item $\frf$ ~--- function that takes "read"-event $e$ and returns a "write"-event from witch $e$ reads
    \item $\ffun{lab} : E \to \lb$ ~--- function that returns event's label
  \end{itemize}
  Also we require
  \begin{itemize}
    \item $\forall e \in E, \ \fpred(e) \leqslant_E e$ and $\frf(e) \leqslant_E e$
    \item $\forall e_1 \ e_2 \in E, \ e_2 = \frf(e_1) \ \Leftrightarrow \ e_1$ is a "read"-event and $e_2$ is a "write"-event with the same location and value
  \end{itemize}
\end{definition}
  
% Далее для простоты будем отождествлять иденфикаторы с их метками, а Execution Event Structure с их множеством итендификаторов

% Теперь наша задача: определить в этих терминах простые структуры событий. Для этого надо определить частичный порядок <= и отношение конфликта #
% Начнем с отношения causality. В нашей статье мы будем считать, что событие e1 влечет событие e2 если 
\begin{itemize}
  \item Programm instruction, that corresponds to event $e_1$ states before the programm instruction, that corresponds to $e_2$
  \item Or $\ e_2$ is the "read"-event and it reads from "write"-event $e_1$
\end{itemize}
% Или формально:
\begin{itemize}
  \item $\fpred(e_1) \ =\ e_2$
  \item Or $\ \frf(e_1) \ =\ e_2$
\end{itemize}
% Любую функцию f можно считать отношением
  $$ a \ f \ b \ \triangleq\ f(a) \ = \ b$$
% Имея ввиду обозначение выше определим
\begin{definition}[causality relation]
  $$\leqslant \ \triangleq \ (\fpred \cup \frf)^* $$
\end{definition}
% Заметим, что в множестве E уже есть тотальный порядок $\leqslant_E$. Нетрудно видеть что полученнле отношение casuality является его предпорядком [смотри Well-foundedness and monads]
\begin{lemma}
  If $\leqslant$ is a casuality order of $E$ then $\leqslant \ \subset \ \leqslant_E$
\end{lemma}
% Теперь давайте определим отношение конфликта. Посмотрев на отношение конфликта в определении СС [ссылка], мы можем установить следущий факт
\begin{lemma}\label{lma_confl}
  If $\ e_1 \leqslant e_2, \ e_3 \leqslant e_4$ and $e_1 \# e_3$ holds then $e_2 \# e_4$
\end{lemma} 
% То есть отношение конфликта должно "протаскиваться" через отношение <=. Наша интуиция будет заключаться в том, что мы определим "минимальное" отношение конфликта, замкнув, котрое по свойству консистентности [ссылка] мы получим полное отношение #. 
% И так откуда берутся конфликты? [тут должен был заход через Step-by-step example]. 
% И так мы видим, что если у событий есть общий предок (относительно отношения fpred) то эти события происходят в двух разных выполнениях программы и, соответвенно находятся в отношении конфликта
\begin{definition}[immediate conflict relation]
  $$ e_1 \, \ffun{icf} \, e_2 \ \triangleq\ \exists e, \, e = \fpred(e_1) = \fpred(e_2)  $$
\end{definition}
% Далее можно определить отношение конфликта как консистентное замыкание icf
\begin{definition}[conflict relation]
  $$ e_1 \, \# \, e_2 \ \triangleq\ \exists e_3\, e_4, e_3 \, \ffun{icf} \, e_4 \ and \ e_3 \leqslant e_1, \, e_4 \leqslant e_2 $$
\end{definition}
% Однако с этим определением возникает одна проблема. Понятно что отношение определенное таким образом получается симметричным и консистентным. Будет ли оно иррефлексивность? Оказывается, что в общем случае нет. Рассмотрим следущую программу:
\input{fig/encode_prog.tex}
% Давайте как в Step-by-step example построим по шагам фрагмент соответвующей этой программе exec_event_structure до чтения из y
\input{fig/encode_part.tex}
% Видно что наша программа в первом потоку разделилась на два независимых выполнения: выполнение в котором мы прочитали из x 1 (обозначим за выболнение (а)) и выполненние в котором прочитали из х 2 (выполнение (b))
%Теперь мы хотим добавить в нашу структуру событий чтение в y. посмотрим что будет если прочитать при выполнении (а) в у 2 (то есть запись из (b))
\input{fig/encode_cf.tex}
We have $\rlab{x}{1} \leqslant \rlab{y}{2}$, $ \rlab{x}{2} \leqslant \rlab{y}{2}$ and $\rlab{x}{1} \ \# \ \rlab{x}{2}$. Thus $\rlab{y}{2} \ \# \ \rlab{y}{2}$ holds (see~\cref{lma_confl})
% Но отношение конфликта должно быть иррефлексивным. Заметим, однако, что (a) и (b) не могут произойти при одном исполнении программы, а значит и чтения R(y,2) из W(y,2) тут быть не должно, полная структура событий тут должна выглядеть так:
\input{fig/encode_full.tex} \\
% Будем говорить, что сткуктура собырий консистентна если там нет чтений из конфликтующийх с ними записей. Формально
\begin{definition}[consistent Execution Event Structure]
  $$consitent\langle E, \ffun{lab}, \fpred, \frf \rangle \ \triangleq \ \forall e \in E, \ \neg (e \ \# \ \frf e)$$
\end{definition}
% Оказывается этого достатчно чтоб отношение конфликта было иррефлексивным
\begin{lemma}
  Let $E$ be a consistent Execution Event Structure (denote as $cexec\_event\_structure$). Then it's conflict relation $\#$ is irreflexive
\end{lemma}
% Получается что из консистентной exevstr можно получить ПCC