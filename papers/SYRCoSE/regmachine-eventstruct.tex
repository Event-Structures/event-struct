\subsection{Event Structure of Register Machine}

In this section we present operational semantics
which constructs a prime event structure encoding a 
set of possible behaviours of the register machine. 

The event structure is constructed incrementally 
in a step-by-step fashion by adding a single event 
on each step. In order to generate a new event 
on each step, we require that events behave as \emph{identifiers}.  

\begin{definition}
  We say that a set $\eventSet$ together with strict partial order $\identOrd$
  form an \emph{identifier set} if:
  \begin{itemize}
    \item there exists a distinguished initial identifier $e_0 \in \eventSet$;
    \item there exists a function $\fresh : \eventSet \fun \eventSet$ which 
      generates a new fresh identifier, \sth
      $$ \forall e \in \eventSet \ldotp e \identOrd \fresh(e) $$
  \end{itemize}
\end{definition}

We will encode the event structure as a tuple 
$\tup{\eventSeq, \lLAB, \lfPO, \lfRF}$ and explain
below the meaning of each component, 
and how they form a prime event structure together.

The first component $\eventSeq$ is a sequence of events 
$e_1 \identOrdDual \dots \identOrdDual e_n$
in reverse order w.r.t the order 
in which events get added to the structure. 
The second component is a labelling function $\lLAB : \eventSet \fun \Lab$, 
assigning a label to each event. 

Next, following the theory of axiomatic weak memory models~\cite{Lahav-al:PLDI17},
we define the causality relation of the register machine's event structure
as the reflexive transitive closure of the union of two relations~---~\emph{program order} 
and \emph{reads-from}, denoted as $\lPO$ and $\lRF$ correspondingly. 

$$ \caOrd \ \defeq \ (\lPO \cup \lRF)^* $$

The program order relation tracks precedence of events within a single thread. 
The reads-from relation captures the flow of values from 
write events to read events, and ensures that values 
do not appear out of thin air~\cite{Boehm-Demsky:MSPC14, Lahav-al:PLDI17}.  

In order to construct $\lPO$ and $\lRF$ incrementally
we represent them via their inverse covering functions $\lfPO$ and $\lfRF$. 

\begin{definition}[Covering]
  Let $\leqslant$ be a partial order. 
  Then $\lessdot$ is covering relation \wrt $\leqslant$ whenever 
  $x \lessdot y$ is true if and only if $x < y$ and 
  there is no $z$ \sth $x < z$ and $z < y$.
  A (non-deterministic) function $f$ from $A$ to the set of finite subsets of $A$ is a covering function if
  its corresponding relation, \ie ${\frel{f} \defeq \set{\tup{x, y} ~|~ y \in f(x)}}$, 
  is a covering relation.
\end{definition}
 
We use the inverse covering function because it is 
more convenient in our setting. Indeed, the semantics adds a new event
at each step. Then it is convenient to require that, in addition,
the small-step relation is provided with the $\lPO$ and $\lRF$
predecessors of a new event.  

\[\def\arraystretch{1.5}
\begin{array}{rcl|rcl}
 
  \lessdot_{\lPO} &\defeq& {\frel{\lfPO}}^{-1}  & \lessdot_{\lRF} &\defeq& {\frel{\lfRF}}^{-1} \\
  \lPO           &\defeq& \lessdot_{\lPO}^+      & \lRF           &\defeq& \lessdot_{\lRF}       \\ 

\end{array}
\] 

We define the conflict relation in two steps. 
First, we define the primitive conflict relation $\primcfRel$ 
which is generated by the $\lfPO$ function.
The two events are considered to be in primitive conflict if they are
not equal and have a common $\lPO$ predecessor. 
For this definition to work properly, we also need 
to assume that each thread has a special initial event 
labelled by a distinguished \emph{thread start} label $\tslab{}$. 
$$ e_1 \primcfRel e_2 \iff e_1 \neq e_2 \wedge \lfPO(e_1) = \lfPO(e2) $$

Second, we extend the primitive conflict along the causality relation:
$$ e_1 \cfRel e_2 \iff 
   \exists e'_1, e'_2 \in \eventSet \ldotp e'_1 \primcfRel e'_2 \land
   e'_1 \caOrd e_1 \land e'_2 \caOrd e_2 $$

We also need a way to reconcile the event structure
with the states of the machine's threads. 
To do so, we use a function ${\thrdmap : \eventSet \fun \ThrdState}$
which maps an event to a thread state obtained as the result of
the execution of the event's side-effect.

Let us consider an example. Given the program below, 
our semantics builds the corresponding event structure as 
shown in \cref{fig:regmachine-eventstruct-example}.

\input{fig/regmachine-eventstruct-prog.tex}

\input{fig/regmachine-eventstruct-example.tex}

The construction starts from an initial event structure
containing, for each thread, an event labelled by $\tslab{}$.
We depict the corresponding thread state below each label.
Initially, each event is mapped to an initial thread state
consisting of an instruction pointer pointing to the first 
instruction to be executed and an initial mapping of registers
denoted as $\bot$.
The first step executes the store instruction from 
the leftmost thread and exits the program, 
since the execution of this thread terminates
(we omit the $\exitInst$ instructions at the end of each thread for brevity).
Next, the store from the rightmost thread is executed and the corresponding
write event gets added to the structure. 
After that, the load instruction from the middle thread is executed. 
Since there are two matching write events in the event structure, 
two conflicting reads are conjoined to the event structure. 
Note that the events can be added non-deterministically in any order
respecting causality. We could have first executed the rightmost thread
and added write $\wlab{x}{2}$ before $\wlab{x}{1}$, 
or we could have added the read with label $\rlab{x}{2}$ 
before another read $\rlab{x}{1}$.  

\input{fig/eventstruct-sem.tex}

The rules of operational semantics constructing 
the event structure are presented in~\cref{fig:eventstruct-sem}.
The first auxiliary rule \ESAddEventRule adds a new event, sets its 
label, $\lPO$ and $\lRF$ predecessors. 
The \ESIdleRule handles the case when a thread of 
the register machine performs an internal step 
without any side effect. 
It chooses an event~$e$ together with 
the thread state~$s$ corresponding to it
and performs one step reduction to a new state~$s'$.
It then updates the mapping of events to thread states.   
The last three rules \ESStoreRule, \ESLoadRule, and \ESLoadBotRule
correspond to store and load performed by some thread.  
Similarly to \ESIdleRule, an event $e_{\lPO}$ is selected
and one reduction is performed from the corresponding thread state~$s$.
Unlike the \ESIdleRule case, however, a new event~$e$ is also generated.
In the case of \ESLoadRule, additionally, an event~$e_{\lRF}$ is selected,
such that it has a write label matching the read label of the new event.    
The rule \ESLoadBotRule corresponds to a case when load 
is performed ``too early'', before any write to the given location is available.

The following theorem asserts that the event structure built this way
indeed satisfies the axioms of the prime event structure.  

\begin{theorem}
  The tuple $\tup{E, \caOrd, \cfRel}$, where $\caOrd$ and $\cfRel$
  are defined as described above, forms prime event structure.
\end{theorem}

We sketch the proof below\footnote{
One can also find its mechanized proof in our \coq development.
}. 

First, we need to show that $\caOrd \ \defeq \ (\lPO \cup \lRF)^*$
is a partial order. Reflexivity and transitivity follows immediately 
from the definition of the reflexive-transitive closure. 
To show antisymmetry note that $\lessdot_{\lPO} \subseteq \identOrd$
and $\lessdot_{\lRF} \subseteq \identOrd$ by construction. 
Therefore $\caOrd$ is a subset of the reflexive closure of $\identOrd$. Since $\identOrd$ is
a partial order, it is antisymmetric, and thus $\caOrd$ should also be antisymmetric.
The axiom of finite cause, \ie $\prefix{e}$ is finite for every event $e$, 
follows from the fact that at each step of the construction 
the set of possible predecessors of the new event 
can be over-approximated by the finite sequence $\eventSeq$.

Second, we need to show that the conflict relation $\cfRel$ defined as 
described above obeys the laws of the conflict relation. 
Trivially, this relation is symmetric, and obeys the hereditary property.
The side condition $\neg (e \cfRel e_{\lRF})$ of the rule \ESLoadRule
ensures that the conflict relation is irreflexive. 

In \cref{fig:eventstruct-example} one can see the prime event structure
obtained as a result of the incremental construction 
depicted in \cref{fig:regmachine-eventstruct-example}.

\input{fig/eventstruct-example.tex}

Once the event structure is constructed, one can extract
the configurations corresponding to the particular runs 
of the parallel register machine, and 
further filter them via the \emph{consistency predicate}
defining the \emph{memory consistency model}.
Our construction of event structures allows to encode 
a wide class of so-called $\lPO\cup\lRF$ acyclic 
relaxed memory models~\cite{Lahav-al:PLDI17}.

For example, a predicate corresponding
to \emph{sequential consistency}~\cite{Lamport:TC79}
requires that the causality order
can be extended to a total order on all events 
of the configuration, such that for each read 
event the last preceding write event 
to the same location has the same value as the read. 
