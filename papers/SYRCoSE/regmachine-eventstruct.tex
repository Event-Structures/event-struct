\subsection{Event Structure of Register Machine}

In this section we present operational semantics
which constructs a prime event structure encoding a 
behaviour of the register machine. 

The event structure is constructed incrementally 
in a step-by-step fashion by adding a single event 
on each step. In order to generate a new event 
on each step we require that events behave as \emph{identifiers}.  

\begin{definition}
  We say that a set $\eventSet$ together with strict partial order $\identOrd$
  form an \emph{identifier set} if:
  \begin{itemize}
    \item there exists a distinguished initial identifier $e_0 \in \eventSet$;
    \item there exists a function $\fresh : \eventSet \fun \eventSet$ which 
      generates a new fresh identifier, \sth
      $$ \forall e \in \eventSet \ldotp e \identOrd \fresh(e) $$
  \end{itemize}
\end{definition}

We will encode the event structure as a tuple 
$\tup{\eventSeq, \lLAB, \lfPO, \lfRF}$ and explain
below the meaning of each component, 
and how they form a prime event structure together.

The first component $\eventSeq$ is a sequence of events 
$e_1 \identOrdDual \dots \identOrdDual e_n$
in reverse order w.r.t the order 
in which events get added to the structure. 
The second component is a labelling function $\lLAB : \eventSet \fun \Lab$, 
assigning a label to each event. 

Next, following the theory of axiomatic weak memory models~\cite{Lahav-al:PLDI17},
we define the causality relation of the register machine's event structure
as the reflexive transitive closure of the union of two relations~---~\emph{program order} 
and \emph{reads-from}, denoted as $\lPO$ and $\lRF$ correspondingly. 

$$ \caOrd \ \defeq \ (\lPO \cup \lRF)^* $$

Program order tracks precedence of events within a single thread. 
Reads-from relation captures the flow of values from 
write events to read events, and ensures that values 
do not appear out of thin-air~\cite{Boehm-Demsky:MSPC14, Lahav-al:PLDI17}.  

In order to construct $\lPO$ and $\lRF$ incrementally
we represent them via their inverse covering functions $\lfPO$ and $\lfRF$. 

\begin{definition}[Covering]
  Let $\leqslant$ be a partial order. 
  Then $\lessdot$ is covering relation \wrt $\leqslant$ whenever 
  $x \lessdot y$ is true if and only if $x < y$ and 
  there is no $z$ \sth $x < z$ and $z < y$.
  A (non-deterministic) function $f : A \fun \pwset{A}$ is a covering function if
  its corresponding relation, \ie ${\frel{f} \defeq \set{\tup{x, y} ~|~ y \in f(x)}}$, 
  is a covering relation.
\end{definition}
 
We use the inverse covering function because it is 
more convenient in our setting. Indeed, the semantics adds a new event
at each step. Then it is convenient to require that in addition 
the small-step relation is provided with the $\lPO$ and $\lRF$
predecessors of a new event.  

\[\def\arraystretch{1.5}
\begin{array}{rcl|rcl}
 
  \lessdot_{\lPO} &\defeq& {\frel{\lfPO}}^{-1}  & \lessdot_{\lRF} &\defeq& {\frel{\lfRF}}^{-1} \\
  \lPO           &\defeq& \lessdot_{\lPO}^+      & \lRF           &\defeq& \lessdot_{\lRF}       \\ 

\end{array}
\] 

The primitive conflict relation is generated by the $\lfPO$ function.
The two events are considered to be in primitive conflict if they are
not equal and have a common $\lPO$ predecessor. 
For this definition to work properly, we also need 
to assume that each thread has a special initial event 
labelled by a distinguished \emph{thread start} label $\tslab{}$. 

$$ e_1 \primcfRel e_2 \iff e_1 \neq e_2 \wedge \lfPO(e_1) = \lfPO(e2) $$

Finally, we need a way to reconcile the event structure
with the states of machine's threads. 
To do so we use a function ${\thrdmap : \eventSet \fun \ThrdState}$
which maps event to a thread state obtained as a result of
execution of event's side-effect.

Let us consider an example. Given the program below, 
our semantics builds the event structure as 
shown in \cref{fig:regmachine-eventstruct-example}.

\input{fig/regmachine-eventstruct-prog.tex}

\input{fig/regmachine-eventstruct-example.tex}

The construction starts from an initial event structure,
containing for each thread an event labelled by $\tslab{}$.
Below the label we depict the corresponding thread state.
Initially, each event is mapped to an initial thread state, 
consisting of an instruction pointer pointing to the first 
instruction to execute, and an initial mapping of registers,
denoted as $\bot$.
The first step executes the store instruction from 
the leftmost thread, and exits the program, 
since the execution of this thread terminates
(we omit $\exitInst$ instructions at the end of each thread for brevity).
Next the store from the rightmost thread is executed and corresponding
write event is added to the structure. 
After that the load instruction from the middle thread is executed. 
Since there are two matching write events in the event structure, 
two conflicting reads are conjoined to the event structure. 
Note that the events can be added non-deterministically in any order
respecting the causality. We could have first execute the rightmost thread
and add write $\wlab{x}{2}$ before $\wlab{x}{1}$, 
or add the read with label $\rlab{x}{2}$ 
before another read $\rlab{x}{1}$.  

\input{fig/eventstruct-sem.tex}

The rules of operational semantics constructing 
the event structure are presented on~\cref{fig:eventstruct-sem}.
The first auxiliary rule \ESAddEventRule adds a new event, sets its 
label, $\lPO$ and $\lRF$ predecessors. 
The \ESIdleRule handles the case when a thread of 
the register machine performs an internal step 
without any side effect. 
It chooses an event $e$ together with 
the thread state $s$ corresponding to it
and performs one step reduction to a new state $s'$.
It then updates the mapping of events to thread states.   
The last two rules \ESStoreRule and \ESLoadRule
correspond to store and load performed by some thread.  
Similarly to \ESIdleRule, an event $e_{\lPO}$ is selected
and one reduction is performed from the corresponding thread state $s$.
Unlike the \ESIdleRule case, however, a new event $e$ is also generated.
In case of \ESLoadRule additionally an event $e_{\lRF}$ is selected,
such that it has a write label matching the read label of the new event.    

The following theorem asserts that the event structure built this way
indeed satisfies the axioms of the prime confusion free event structure.  

\begin{theorem}
  The tuple $\tup{E, \caOrd, \primcfRel}$, where $\caOrd$ and $\primcfRel$
  are defined as described above, forms prime confusion-free event structure.
\end{theorem}

We sketch the proof below. 

First, we need to show that $\caOrd \ \defeq \ (\lPO \cup \lRF)^*$
is a partial order. Reflexivity and transitivity follows immediately 
from the definition of the reflexive-transitive closure. 
To show antisymmetry note that $\lessdot_{\lPO} \subseteq \identOrd$
and $\lessdot_{\lRF} \subseteq \identOrd$ by construction. 
Therefore $\caOrd \subseteq \identOrd$. Since $\identOrd$ is
partial order, it is antisymmetric, and thus $\caOrd$ should also be antisymmetric.
The axiom of finite cause, \ie $\prefix{e}$ is finite for every event $e$, 
follows from the fact that at each step of the construction 
the set of possible predecessors of the new event 
can be over-approximated by the finite sequence $\eventSeq$.

Second, we need to show that the conflict relation defined as 
$ e_1 \primcfRel e_2 \iff e_1 \neq e_2 \wedge \lfPO(e_1) = \lfPO(e2) $
obeys the laws of primitive conflict relation. 
Trivially, this relation is irreflexive, symmetric, and transitive.
Also, it is easy to see that it satisfies choice-locality. 
The side condition $\neg (e_{\lPO} \cfRel e_{\lRF})$ of the rule \ESLoadRule
ensures that the primitive conflict relation would not violate 
hereditary property. 

In \cref{fig:eventstruct-example} one can see the prime event structure
obtained as a result of incremental construction 
depicted in \cref{fig:regmachine-eventstruct-example}.

\input{fig/eventstruct-example.tex}

Once the event structure is constructed, one can extract
the configurations corresponding to the particular runs 
of the parallel register machine, and 
further filter them via \emph{consistency predicate}
defining the \emph{memory consistency model}.
Our construction of the event structures allows to encode 
a wide class of so-called $\lPO\cup\lRF$ acyclic 
relaxed memory models~\cite{Lahav-al:PLDI17}.
