\section{Introduction}

\subsection{Motivation}

% Терия структур событий (СС) была придумана Винскелем в 19?? году [статья]. С тех пор она активно развивалась, в различных статьях рассматривалось как различные подходы к этой теории: в [этих статьях] рассмотриваласть категорная семантика, в [этих статьях] [какая-то другая], так и применение СС можно в различных проложениях.

% Для каких же приложений можно использовать СС теорию? Например, для задания формальной семантики конкуретных систем [ссылки]. Истина познается в сравнении, так что давайте попробуем понять неформальный смысл СС на примере задания семнатики какой-нибудь параллельной программы

% Рассмотрим следущую параллельную программу
\begin{tikzpicture}

      \node (iwy) %[left of = mid, node distance = 1.1cm] 
      at (-1.3, 2.5)
      {$x:=1;$};

      \node (irx) [above = -0.5cm of iwy.west, anchor = west] 
      {$r:=x;$};

      \node (iwx) %[right of = mid, node distance = 0.8cm] 
       at (0.5, 2.5)
      {$x:=2;$};


      \draw ($ (iwy.south east) + (0.1,-0.5) $) -- ($ (iwy.south east) + (0.1,0.6) $);
      \draw ($ (iwx.south west) + (-0.15,-0.5) $) -- ($ (iwx.south west) - (0.15,-0.6) $);
\end{tikzpicture}
% Программа разделяется на два потока: в первом мы пишем в х 1, потом читаем из него что-то в r, а во втором пишем в х 2. Вопрос: что окажется в переменной r после исполнения программы?
% Если мы, например, выполним сначала инструкции из первого потока, а потом из второго то в r окажется 1. Такое поведение отражается на следующей диаграмме:

\begin{tikzpicture}
    \node (ts1) at (-3,2) {ThreadStart};
    \node (ts2) at (-1, 2) {ThreadStart};
    \node (wxo) at (-3,0.2) {$\wlab{x}{1}$};
    \node (wxt) at (-1,0.2) {$\wlab{x}{2}$};
    \node (rxo) at (-3, -2.2) {$\rlab{x}{1}$};
    \draw[ca] (wxo)  -- node{$\leqslant\qquad$}  (ts1);
    \draw[ca] (wxt)  -- node{$\leqslant\qquad$}  (ts2);
    \draw[ca] (rxo)  -- node{$\leqslant\qquad$}  (wxo);
\end{tikzpicture}

% В этой диаграмме мы следим за тем, что происходит с переменной x. Тут есть несколько типов событий:
% - W(x,u) означает что мы записали в x u
% - R(x,u) означает что мы прочитали из x u
% - ThreadStart означает начало потока
% Так же на этой диаграмме есть отношение $\leq$ -- причинно следственная связь между собыитиями: например оно связывает W(x,1) и R(x,1), что логично, так как запись в x 1 повлекла чтение из x 1 (формально в 2A)
% Но возможно и другое исполнение программы в котором из x мы прочитаем 2. Ему соотвесвует другая диаграмма:
\begin{tikzpicture}
    \node (ts1) at (-3,2) {ThreadStart};
    \node (ts2) at (-1, 2) {ThreadStart};
    \node (wxo) at (-3,0.2) {$\wlab{x}{1}$};
    \node (wxt) at (-1,0.2) {$\wlab{x}{2}$};
    \node (rxt) at (-3, -2.2) {$\rlab{x}{2}$};
    \draw[ca] (wxo)  -- node{$\leqslant\qquad$}  (ts1);
    \draw[ca] (wxt)  -- node{$\leqslant\qquad$}  (ts2);
    \draw[ca] (rxt)  -- node{$\leqslant\qquad$}  (wxo);
    \draw[ca] (rxt)  -- node{$\leqslant\qquad$}  (wxt);
\end{tikzpicture}
% Заметим что, то тут образовалась новая стрелка из W(x,2) в R(x,2), так как чтение из x 2 не могло бы произойти еслиб мы туда 2 не записывали. Однако стрелка из W(x,1) тоже не исчезла, потому что, $x := 1$ в программе стоит перед $r := x$, а значит мы не можем выполнить $r := x$ не выполнив перед этим $x := 1$.
%  Тут мы видим, что при чтении их x мы столкнулись с некоторой недетерменнированностью, которая отразилось в том, что у нас появилось целое множество графоф, соотвествующих разным исполнения программы
% По множеству всех таких возможных графов можно понять все возможные поведения программы, однако с ростом недетеменированности в каком-то одном месте растет количество графов, которые отличаются друг от друга только там. Хочется использовать такой формализм, который позволил бы описывать локальный недетерменизм более компактно.   
% Здесь нам как раз может помочь второе отношение, присутсвующее в структурах собыий — это отношение конфликта между событиями: e1 # e2. 
% Оно обозначает, что e1 и e2 не могут произойти в одном исполнении программы например R(x,2) и R(x,1) из примера выше. За счет этого в одной СС можно закодировать сразу несколько иполнений программы [статьи], а так же моделировать исполнения, в которых, в ходе оптимизаций, произошли перестановки различных интрукций [про LB и es]. 
% Вот так кодируется наш пример с использованием отношкния конфликта
\begin{tikzpicture}
    \node (ts1) at (-3,2) {ThreadStart};
    \node (ts2) at (-1, 2) {ThreadStart};
    \node (wxo) at (-3,0.2) {$\wlab{x}{1}$};
    \node (wxt) at (-1,0.2) {$\wlab{x}{2}$};
    \node (rxt) at (-2, -2.2) {$\rlab{x}{2}$};
    \node (rxo) at (-4, -2.2) {$\rlab{x}{1}$};
    \draw[ca] (wxo)  -- node{$\leqslant\qquad$}  (ts1);
    \draw[ca] (wxt)  -- node{$\leqslant\qquad$}  (ts2);
    \draw[ca] (rxt)  -- node{$\leqslant\qquad$}  (wxo);
    \draw[ca] (rxt)  -- node{$\leqslant\qquad$}  (wxt);
    \draw[ca] (rxo)  -- node{$\leqslant\qquad$}  (wxo);
    \draw[cf] (rxo)  -- node[above]{$\#$}  (rxt);
\end{tikzpicture}

\subsection{Problem Statement}

% В существующих работах по структурам событий обычно результаты либо не формализованы ни в каких пруф-ассистантах [ссылки], либо слишком привязаны к конкретной предметной области или задаче [ссылки], что затрудняет переиспользование теории структур событий в других проектах [расписать про это в Related Works].

%Нашей задачей стало решить две, описанные выше, проблемы \\ 1) Формализовать теорию СС в каком-нибудь proof-assistance: предоставить леммы и тактики упрощаюшие работу с СС и доказать основные результаты, описанные в статьях 

% \\ 2) Показать, как нашу библиотеку можно использовать для решения прикладных задач, например для задания  семантики абстрактной регистровой машины с слабо-согласованной моделью разделяемой памяти.

%\subsection{Outline} %описание статьи 
