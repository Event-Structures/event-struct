\section{Introduction}

Event structures is a mathematical formalism introduced 
by Winskel~\cite{Winskel:86} as a semantic domain of concurrent programs.
In recent years there is a renewed interest in event structures, 
with the applications of the theory ranging from relaxed memory models%
~\cite{Jeffrey-Riely:LICS16, PichonPharabod-Sewell:POPL16, Chakraborty-Vafeiadis:POPL19}
to model-based mutation testing~\cite{Fellner-al:VMCAI2020}.
\eupp{perhaps, we could add more citations once the related work is ready.}

The main advantage of the event structures 
compared to traditional interleaving semantics 
is that they give a more compact and consice 
representation of progams' behavior.
For example, consider the following code snippet. 

\input{fig/intro-prog.tex}

Under the interleaving semantics 
it has $3! = 6$ traces with each trace consisting of $4$ events,
as depicted on \cref{fig:intro-traces}.
Event themselves represent atomic side-effects 
of instructions' execution. In our case 
it is either a write of a value to a shared variable $\wlab{x}{a}$,
or a read of a particular value from a shared variable $\rlab{x}{a}$.  

\input{fig/intro-traces.tex}

The same information can be encoded in a single 
event structure containing $6$ events in total
(see \cref{fig:intro-es}). 
In the event structure there are two types of edges 
between the events. The gray arrows $e_1 \arrowCA e_2$ 
represent the \emph{causality relation}, a 
partial order reflecting the causal relationship
between the atomic events of computation.
The red edges $e_1 \arrowCF e_2$ represent 
the \emph{conflict relation} which is 
a symmetric and irreflexive relation 
encoding mutually exclusive events.
Each particular trace can be extracted from the event structure
as a linearisation of some \emph{configuration}, 
that is a causally-closed and conflict-free 
subset of events. 

\input{fig/intro-es.tex}

In the programming language and formal semantics research community 
it become the de-facto standard to complement the theoretical 
studies with their mechanization in the \emph{proof assistants}
like Coq, Agda, Isabelle, Arend, and others,
as this process increases the reliability and reproducibility 
of the scientific results.
Yet, as far as we know, there is a little work on 
mechanization of event structures theory. 

Our work is aimed to close this gap. 
Our goal is to develop a Coq library containing 
a comprehensive set of common definitions, lemmas, 
and tactics that would allow the researchers 
to utilize the theory of event structures 
for the needs of their domain. 

In this work in progress report we sketch 
the common design princples behind our library
and give a concrete example of its usage  
by developing a formal mechanized semantics of simple 
register machine with shared memory. 

\subsection{Motivation}

% Терия структур событий (СС) была придумана Винскелем в 19?? году [статья]. С тех пор она активно развивалась, в различных статьях рассматривалось как различные подходы к этой теории: в [этих статьях] рассмотриваласть категорная семантика, в [этих статьях] [какая-то другая], так и применение СС можно в различных проложениях.

% Для каких же приложений можно использовать СС теорию? Например, для задания формальной семантики конкуретных систем [ссылки]. Истина познается в сравнении, так что давайте попробуем понять неформальный смысл СС на примере задания семнатики какой-нибудь параллельной программы

% Рассмотрим следущую параллельную программу
\begin{tikzpicture}

      \node (iwy) %[left of = mid, node distance = 1.1cm] 
      at (-1.3, 2.5)
      {$x:=1;$};

      \node (irx) [above = -0.5cm of iwy.west, anchor = west] 
      {$r:=x;$};

      \node (iwx) %[right of = mid, node distance = 0.8cm] 
       at (0.5, 2.5)
      {$x:=2;$};


      \draw ($ (iwy.south east) + (0.1,-0.5) $) -- ($ (iwy.south east) + (0.1,0.6) $);
      \draw ($ (iwx.south west) + (-0.15,-0.5) $) -- ($ (iwx.south west) - (0.15,-0.6) $);
\end{tikzpicture}
% Программа разделяется на два потока: в первом мы пишем в х 1, потом читаем из него что-то в r, а во втором пишем в х 2. Вопрос: что окажется в переменной r после исполнения программы?
% Если мы, например, выполним сначала инструкции из первого потока, а потом из второго то в r окажется 1. Такое поведение отражается на следующей диаграмме:

\begin{tikzpicture}
    \node (ts1) at (-3,2) {ThreadStart};
    \node (ts2) at (-1, 2) {ThreadStart};
    \node (wxo) at (-3,0.2) {$\wlab{x}{1}$};
    \node (wxt) at (-1,0.2) {$\wlab{x}{2}$};
    \node (rxo) at (-3, -2.2) {$\rlab{x}{1}$};
    \draw[ca] (wxo)  -- node{$\leqslant\qquad$}  (ts1);
    \draw[ca] (wxt)  -- node{$\leqslant\qquad$}  (ts2);
    \draw[ca] (rxo)  -- node{$\leqslant\qquad$}  (wxo);
\end{tikzpicture}

% В этой диаграмме мы следим за тем, что происходит с переменной x. Тут есть несколько типов событий:
% - W(x,u) означает что мы записали в x u
% - R(x,u) означает что мы прочитали из x u
% - ThreadStart означает начало потока
% Так же на этой диаграмме есть отношение $\leq$ -- причинно следственная связь между собыитиями: например оно связывает W(x,1) и R(x,1), что логично, так как запись в x 1 повлекла чтение из x 1 (формально в 2A)
% Но возможно и другое исполнение программы в котором из x мы прочитаем 2. Ему соотвесвует другая диаграмма:
\begin{tikzpicture}
    \node (ts1) at (-3,2) {ThreadStart};
    \node (ts2) at (-1, 2) {ThreadStart};
    \node (wxo) at (-3,0.2) {$\wlab{x}{1}$};
    \node (wxt) at (-1,0.2) {$\wlab{x}{2}$};
    \node (rxt) at (-3, -2.2) {$\rlab{x}{2}$};
    \draw[ca] (wxo)  -- node{$\leqslant\qquad$}  (ts1);
    \draw[ca] (wxt)  -- node{$\leqslant\qquad$}  (ts2);
    \draw[ca] (rxt)  -- node{$\leqslant\qquad$}  (wxo);
    \draw[ca] (rxt)  -- node{$\leqslant\qquad$}  (wxt);
\end{tikzpicture}
% Заметим что, то тут образовалась новая стрелка из W(x,2) в R(x,2), так как чтение из x 2 не могло бы произойти еслиб мы туда 2 не записывали. Однако стрелка из W(x,1) тоже не исчезла, потому что, $x := 1$ в программе стоит перед $r := x$, а значит мы не можем выполнить $r := x$ не выполнив перед этим $x := 1$.
%  Тут мы видим, что при чтении их x мы столкнулись с некоторой недетерменнированностью, которая отразилось в том, что у нас появилось целое множество графоф, соотвествующих разным исполнения программы
% По множеству всех таких возможных графов можно понять все возможные поведения программы, однако с ростом недетеменированности в каком-то одном месте растет количество графов, которые отличаются друг от друга только там. Хочется использовать такой формализм, который позволил бы описывать локальный недетерменизм более компактно.   
% Здесь нам как раз может помочь второе отношение, присутсвующее в структурах собыий — это отношение конфликта между событиями: e1 # e2. 
% Оно обозначает, что e1 и e2 не могут произойти в одном исполнении программы например R(x,2) и R(x,1) из примера выше. За счет этого в одной СС можно закодировать сразу несколько иполнений программы [статьи], а так же моделировать исполнения, в которых, в ходе оптимизаций, произошли перестановки различных интрукций [про LB и es]. 
% Вот так кодируется наш пример с использованием отношкния конфликта
\begin{tikzpicture}
    \node (ts1) at (-3,2) {ThreadStart};
    \node (ts2) at (-1, 2) {ThreadStart};
    \node (wxo) at (-3,0.2) {$\wlab{x}{1}$};
    \node (wxt) at (-1,0.2) {$\wlab{x}{2}$};
    \node (rxt) at (-2, -2.2) {$\rlab{x}{2}$};
    \node (rxo) at (-4, -2.2) {$\rlab{x}{1}$};
    \draw[ca] (wxo)  -- node{$\leqslant\qquad$}  (ts1);
    \draw[ca] (wxt)  -- node{$\leqslant\qquad$}  (ts2);
    \draw[ca] (rxt)  -- node{$\leqslant\qquad$}  (wxo);
    \draw[ca] (rxt)  -- node{$\leqslant\qquad$}  (wxt);
    \draw[ca] (rxo)  -- node{$\leqslant\qquad$}  (wxo);
    \draw[cf] (rxo)  -- node[above]{$\#$}  (rxt);
\end{tikzpicture}

\subsection{Problem Statement}

% В существующих работах по структурам событий обычно результаты либо не формализованы ни в каких пруф-ассистантах [ссылки], либо слишком привязаны к конкретной предметной области или задаче [ссылки], что затрудняет переиспользование теории структур событий в других проектах [расписать про это в Related Works].

%Нашей задачей стало решить две, описанные выше, проблемы \\ 1) Формализовать теорию СС в каком-нибудь proof-assistance: предоставить леммы и тактики упрощаюшие работу с СС и доказать основные результаты, описанные в статьях 

% \\ 2) Показать, как нашу библиотеку можно использовать для решения прикладных задач, например для задания  семантики абстрактной регистровой машины с слабо-согласованной моделью разделяемой памяти.

%\subsection{Outline} %описание статьи 
